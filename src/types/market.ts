export enum OrderType {
  LIMIT = 'LIMIT',
  MARKET = 'MARKET',
  // Future: STOP_LOSS, STOP_LOSS_LIMIT, TAKE_PROFIT, TAKE_PROFIT_LIMIT
}

export enum OrderSide {
  BUY = 'BUY',
  SELL = 'SELL',
}

export enum OrderStatus {
  OPEN = 'OPEN',                // Actively on the book
  PARTIALLY_FILLED = 'PARTIALLY_FILLED',
  FILLED = 'FILLED',
  CANCELLED = 'CANCELLED',      // Cancelled by user or system
  REJECTED = 'REJECTED',        // Could not be placed (e.g. insufficient funds, invalid params)
  EXPIRED = 'EXPIRED',          // If timeInForce or expiry is implemented
}

// Defines the configuration for a tradable pair
export interface TradingPair {
  _id: string;                    // Unique identifier for the pair, e.g., "BTC_USDT" or a hash.
  baseAssetSymbol: string;        // The asset being traded (e.g., BTC)
  baseAssetIssuer: string;        // Issuer of the base asset
  quoteAssetSymbol: string;       // The asset used for pricing (e.g., USDT)
  quoteAssetIssuer: string;       // Issuer of the quote asset
  tickSize: number;               // Minimum price increment (e.g., 0.01 for a price like 123.45)
  lotSize: number;                // Minimum quantity increment (aka stepSize) (e.g., 0.0001 for BTC)
  minNotional: number;            // Minimum order value (price * quantity) in quote asset (e.g., 10 USDT)
  status: string;                 // e.g., 'TRADING', 'PAUSED', 'DELISTED', 'PRE_TRADE'
  createdAt: string;              // ISO Date string
  // Future: maxMarketOrderQuantity, etc.
}

// Represents an order placed by a user
export interface Order {
  _id: string;                    // Unique order ID, generated by the system
  userId: string;                 // Account ID of the user who placed the order
  pairId: string;                 // Reference to TradingPair._id
  
  baseAssetSymbol: string;        // From TradingPair for easier querying/display
  quoteAssetSymbol: string;       // From TradingPair

  type: OrderType;
  side: OrderSide;
  status: OrderStatus;

  price?: number;                 // Required for LIMIT orders; the price per unit of baseAsset in terms of quoteAsset
  quantity: number;               // Desired amount of baseAsset to buy/sell
  
  filledQuantity: number;         // Amount of baseAsset that has been filled
  averageFillPrice?: number;      // Average price at which the order was filled (if partially/fully filled)
  cumulativeQuoteValue?: number;  // Total value in quoteAsset for filled portion (filledQuantity * averageFillPrice)

  // For MARKET orders, a client might specify how much quote currency they want to spend (for BUY)
  // or how much base currency they want to sell (for SELL, same as quantity).
  // e.g. "Buy BTC with 1000 USDT". If 'quoteOrderQty' is used, 'quantity' might be indicative or calculated.
  quoteOrderQty?: number;         

  createdAt: string;              // ISO Date string
  updatedAt: string;              // ISO Date string of the last status change or fill
  
  // Optional: For more advanced order types or features
  timeInForce?: 'GTC' | 'IOC' | 'FOK'; // Good-Til-Cancelled, Immediate-Or-Cancel, Fill-Or-Kill
  expiresAt?: string;             // ISO Date string for orders with an expiry
  // clientOrderId?: string;      // User-defined ID for their reference
  // stopPrice?: number;          // For STOP_LOSS / TAKE_PROFIT orders
}

// Represents an executed trade between two orders
export interface Trade {
  _id: string;                    // Unique trade ID
  pairId: string;                 // Reference to TradingPair._id
  
  baseAssetSymbol: string;
  quoteAssetSymbol: string;

  makerOrderId: string;           // ID of the order that was resting on the book (maker)
  takerOrderId: string;           // ID of the order that matched with the maker (taker)
  
  price: number;                  // Price at which the trade was executed
  quantity: number;               // Amount of baseAsset traded
  
  buyerUserId: string;            // User ID of the buyer
  sellerUserId: string;           // User ID of the seller
  
  timestamp: string;              // ISO Date string of when the trade occurred
  
  isMakerBuyer: boolean;          // True if the buyer was the maker, false if taker was buyer
                                  // (Alternatively, could deduce from makerOrderId's side)

  // Fees
  feeAmount?: number;             // Total fee paid for this trade
  feeCurrency?: string;           // Symbol of the currency the fee was paid in (could be base, quote, or a native token)
  // individual fees for maker/taker can also be stored if they differ
  // makerFee?: number;
  // takerFee?: number;
}

// Represents a single price level in the order book
export interface OrderBookLevel {
  price: number;
  quantity: number;               // Total quantity of baseAsset available at this price
  orderCount?: number;            // Optional: number of individual orders at this level
}

// Represents a snapshot of the order book for a given pair
export interface OrderBookSnapshot {
  pairId: string;                 // Reference to TradingPair._id
  timestamp: string;              // ISO Date string of when the snapshot was taken
  lastUpdateId?: number;          // Sequence number for diff updates (like Binance API)
  bids: OrderBookLevel[];         // Buy orders, sorted descending by price (highest bid first)
  asks: OrderBookLevel[];         // Sell orders, sorted ascending by price (lowest ask first)
}

// For operations that create/update orders/pairs
export interface MarketCreatePairData {
    baseAssetSymbol: string;
    baseAssetIssuer: string;
    quoteAssetSymbol: string;
    quoteAssetIssuer: string;
    tickSize: number;
    lotSize: number;
    minNotional: number;
    initialStatus?: string; // Default to 'TRADING' or 'PRE_TRADE'
}

export interface MarketPlaceOrderData {
    userId: string; // Will be sender
    pairId: string;
    type: OrderType;
    side: OrderSide;
    price?: number; // Required for LIMIT
    quantity: number;
    quoteOrderQty?: number; // For MARKET BUY by quote amount
    timeInForce?: 'GTC' | 'IOC' | 'FOK';
    // clientOrderId?: string;
}

export interface MarketCancelOrderData {
    userId: string; // Will be sender
    orderId: string;
    pairId: string; // Useful for routing/sharding if books are managed per pair
} 